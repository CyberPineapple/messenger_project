# Спецификация

В данном релизе бекэнд содержит в себе следующий функционал:

* регистрация и авторизация пользователя;
* выход пользователя из системы;
* шифрование пароля;
* сессия пользователя;
* создание чата и чата с паролем;
* удаление чата;
* передача сообщений между пользователями;
* передача изображений между пользователями.

## 1. Регистрация и авторизация пользователя

При регистрации к пользователю предъявляются следующие требования:
	* длина логина не больше 20 символов;
	* логин должен быть уникальным.

### Регистрация

Для регистрации пользователя, клиент должен отправить следующий json-запрос

```json
{
	"Type": "registration",
	"Login": "user",
	"Password": "password"
}
```

Сервер ответит

```json
{
	"Type": "registration",
	"Status": "success"
}
```

### Зарегистрированный пользователь

Если пользователь попробует зарегистрироваться под уже имеющимся в базе логином, то сервер ответит так

```json
{
	"Type": "registration",
	"Status": "user exist"
}
```

***FAQ***

*Нужно ли авторизовываться после регистрации?*
Нет, не нужно. Однако стоит проверить этот факт.

### Авторизация

Для авторизации пользователя, клиент должен отправить следующий json-запрос

```json
{
	"Type":"login",
	"Login": "user",
	"Password": "password"
}
```

Сервер ответит

```json
{
	"Type": "login",
	"Status": "success"
}
```

### Неверный пароль или несуществующий пользователь
Если пользователь введет неверный пароль или логин не существует в базе, сервер ответит ему так

```json
{
	"Type": "login",
	"Status": "error"
}
```

## 2. Выход пользователя из системы
Чтобы совершить выход из системы, клиент должен отправить на сервер

```json
{
	"Type": "logout",
	"Login": "user"
}
```

Сервер ответит

```json
{
	"Type": "logout",
	"Status": "success"
}
```

**(?)** Однако стоит задуматься, нужно ли вообще серверу отправлять ответ?

### Выход не авторизованного пользователя
Если пользователь не имеющий логина и не авторизованный в системе отправит запрос на выход, сервер ответит так

```json
{
	"Type": "logout",
	"Status": "error"
}
```

## 3. Шифрование паролей
Пользователь может быть спокоен, пароли от акканта хранятся в sha-512 + salt(sha256 + random), пароли от чата хранятся в sha-256 + salt(sha128 + random).


## 4. Сессия пользователя
Сессия пользователя автоматически создаётся при входе или регистрации пользователя. Сессия хранит идентификатор пользователя и время входа в систему и текущий чат.

## 5. Чат
При создании чата перед пользователем предъявляются следующие требования:
	* длина имени чата не должна превышать 32 символов;
	* пользователь должен быть авторизован в системе.

### Создание
Для создания чата клиент должен отправить json-запрос с следущим содержанием

```json
{
	"Type": "chat",
	"Command": "create",
	"Chat": "general"
}
```

При успешном создании чата сервер ответит

```json
{
	"Type": "chat",
	"Status": "success"
}
```

Если не авторизованный пользователь попробует создать чат, сервер ответит ему так

```json
{
	"Type": "login",
	"Status": "error"
}
```

### Создание чата с паролем

Для создания чата с паролем необходимо добавить еще одно поле Password, для установки пароля.

```json
{
	"Type": "chat",
	"Command": "create",
	"Chat": "general secret",
	"Password": "secret"
}
```
При успешном создании чата с паролем сервер ответит

```json
{
	"Type": "chat",
	"Status": "success"

}
```

Если пользователь попытается создат чат с уже имеющимся названием в базе, сервер ответит

```json
{
	"Type": "chat",
	"Status": "chat exist"
}
```

### Удаление чата
Для удаления чата необходимы следующие условия условие

	* пользователь должнен быть создателем чата
	* пользователь должен выбрать чат ("Command": "choice")

Удаление чата **с паролем** и **без** приходит **без изменений**

Для удаления пользователь должен отправить следующий json запрос

```json
{
	"Type": "chat",
	"Command": "delete"
}
```

При успешном запросе сервер ответит

```json
{
	"Type": "chat",
	"Command": "delete",
	"Status": "success"
}
```

Важно, что после удаления чата, все пользователи удаленного чата будут перенапралены в чат **general**

Если пользователь не имеющий право(условия описаны выше) удалять, попытается удалить, сервер ответит так

```json
{
	"Type": "chat",
	"Command": "delete",
	"Status": "error"
}
```



### Получить список чатов
Для получения всех чатов клиент должен отправить

```json
{
	"Type": "chat",
	"Command": "list"
}
```

Сервер ответит

```json
{
	"Type": "chat",
	"Chats": [
	{
		"Chat": "general",
		"Closed": false
	},
	{
		"Chat": "secret general",
		"Closed": true
	}
 ]
}
```

В поле Chats **все** чаты системы. В поле Chat находится имя чата, поле Closed - признак чата под паролем чата. True - пароль есть.

Если не авторизованный пользователь попытается получить чаты, то сервер ответит

```json
{
	"Type": "login",
	"Status": "error"
}
```

### Вход в чат без пароля

По умолчанию, после авторизации пользователь оказывется в чате general, для входа в чат клиенту нужно отправить

```json
{
	"Type": "chat",
	"Chat": "general",
	"Command": "choice"
}
```

Сервер ответит

```json
{
	"Type": "chat",
	"Command": "choice",
	"Messages": [
	{
		"user": "user",
		"text": "Hello from past",
		"date": "1970-01-03 03:59:00"
	},
	{
		"user": "user",
		"text": "Hey, there is somebody?",
		"date": "2019-05-04 20:00:00"
	}
 ]
}
```
Где **Messages** это массив с json объектам.

### Вход в чат под паролем

По умолчанию, после авторизации пользователь оказывется в чате general, для входа в чат с паролем клиенту нужно отправить серверу

```json
{
	"Type": "chat",
	"Command": "choice",
	"Chat": "secret general",
	"Password": "secret"
}
```

При вверно введеном пароле сервер ответит

```json
{
	"Type": "chat",
	"Messages": [
	{
		"user": "user",
		"text": "Встретимся на остановке",
		"date": "2019-01-01 03:59:00"
	}
 ]
}
```

Где **Messages** это массив с json объектам.

Если пользователь захочет посмотреть одим глазком в закрытый чат, не имея пароля

```json
{
	"Type":"chat",
	"Command":"choice",
	"Chat":"secret general"
}
```

Сервер лишь помахает пальцем

```json
{
	"Type": "chat",
	"Status": "access denied"
}
```

Или пользователь забыл пароль

```json
{
	"Type":"chat",
	"Command":"choice",
	"Chat":"secret general",
	"Password": "terces"
}
```

Сервер ответит аналогично

```json
{
	"Type": "chat",
	"Status": "access denied"
}
```
### Получить более ранние сообщения

По умолчанию сервер отдает последние 30 сообщений, чтобы избежать нагрузки на сервер.

Если клиенту нужно получить раннее отправленные сообщения, то нужно отправить

```json
{
	"Type": "chat",
	"Command": "earlier"
}
```

На что сервер ответит массивом из 15 или меньше сообщений.

```json
{
	"Type": "chat",
	"Command": "earlier",
	"Messages": [
	{
		"user": "login",
		"text": "Hello from past",
		"date": "1970-01-03 03:59:00"
	},
	{
		"user": "user",
		"text": "Hey, there is somebody?",
		"date": "2019-05-04 20:00:00"
	}
 ]
}
```

Если клиент достиг ~~дна~~ начала переписки, сервер отправит

```json
{
	"Type": "chat",
	"Command": "earlier",
	"Messages": []
}
```


## 6. Сообщения
Перед отправкой сообщения пользователь должен быть:

	* авторизован;
	* чат должен существовать.

Прежде чем отправить сообщение пользователь должен выбрать чат.

```json
{
	"Type": "chat",
	"Chat": "general",
	"Command": "choice"
}
```
Только после, пользователь может приступать к отправке сообщения.

Для отправки сообщения в чат клиент должен отправить сообщение

```json
{
	"Type": "chat",
	"Command": "message",
	"Text": "Hey, there is somebody?"
}
```

На что сервер ответит, точно таким же сообщением каждому подключенному пользователю

```json
{
	"Type": "chat",
	"Command": "message",
	"Message": {
		"user": "user",
		"text": "Hey, there is somebody?",
	}
}
```

**Почему так?** Это происходит потому что, все общение идет через сервер. А значит мы должны отправлять только те сообщения которые гарантированно дошли до сервера и сохранены в базе.

Если пользователь попрообует отправить сообщение не авторизованныем или не выбрав чат, сервер ответит

```json

{
	"Type": "chat",
	"Command": "message",
	"Status": "error in chat or user"
}
```

**(?)** Обработать сообщение "Status": "error", например когда база недоступна или память кончилась, или сервер упал.

Если авторизованный пользователь попробует отправить в несуществующий чат сервер ему ответит

```json
{
	"Type": "chat",
	"Status": "error"
}
```

### Отправка изображения

Для отправки изображения клиент должен перевести изображение в base64

```json
{
	"Type": "chat",
	"Command":"message",
	"Image": "WW91IGEgcGlkb3IK"
}
```
В случае успеха сервер ответит

```json
{
	"Type": "chat",
	"Command": "message",
	"Message": {
		"user": "user",
		"image": "WW91IGEgcGlkb3IK",
	}
}
```

### Отправка изображения с сообщением

Все так же как и с отправкой изображения, для отправки изображения клиент должен перевести изображение в base64

```json
{
	"Type": "chat",
	"Command":"message",
	"Image": "WW91IGEgcGlkb3IK",
	"Text": "LOL"
}
```
В случае успеха сервер ответит

```json
{
	"Type": "chat",
	"Command": "message",
	"Message": {
		"user": "user",
		"image": "WW91IGEgcGlkb3IK",
		"text": "LOL"
	}
}
```

Так будет с каждым, кто дочитает спецификацию до конца.

Команда для создания базы данных с utf-8 кодировкой
create database Messenger with encoding='utf-8' LC_CTYPE='en_US.utf8' LC_COLLATE='en_US.utf8' TEMPLATE template0;
